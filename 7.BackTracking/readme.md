！！！！总结：
    回溯法解决的问题都可以抽象为树形结构：
        因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度，都构成的树的深度。递归就要有终止条件，所以必然是一棵高度有限的树
        回溯法抽象为树形结构后，其遍历过程就是：for循环横向遍历，递归纵向遍历，回溯不断调整结果集。
        去重一定要对元素进行排序，这样我们才方便通过相邻的节点来判断是否重复使用了。去重有两种写法
        去重情况：
        树枝去重：used[i - 1] == true，说明同一树枝candidates[i - 1]使用过
        树层去重：used[i - 1] == false，说明同一树层candidates[i - 1]使用过
    回溯三部曲：
        1.回溯函数模板返回值以及参数：void backtracking(参数)
            在回溯算法中，我的习惯是函数起名字为backtracking，回溯算法中函数返回值一般为void，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数
            startIndex什么时候需要，什么时候不需要：可重复就不需要
            那么既然是无序，取过的元素不会重复取，写回溯算法的时候，for就要从startIndex开始，而不是从0开始！
        2.回溯函数终止条件：if (终止条件) {
                                存放结果;
                                return;
                            }
            一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归
        3.回溯搜索的遍历过程：
                            for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
                                处理节点;
                                backtracking(路径，选择列表); // 递归
                                回溯，撤销处理结果
                            }
            回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。


            题目                                        思路
组合类：N个数里面按一定规则找出k个数的集合
    77.组合                           犯了一个很典型的错误！！！！！！ 二位切片添加切片的两种写法
    17.电话号码的字母组合         如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex
    39.组合总和            如果是一个集合来求组合的话，就需要startIndex
      40.组合总和Ⅱ
      216.组合总和Ⅲ
分割类：一个字符串按一定规则有几种切割方式           分割思想有两种写法，道理都一样
    131.分割回文串
    93.复原IP地址
子集类：一个N个数的集合里有多少符合条件的子集 ，如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！
    78.子集                                 注意收集全部节点在哪个部分收集 主要因为有空集
    90.子集Ⅱ                                去重问题就要排序：used去重和set去重
排列类：N个数按一定规则全排列，有几种排列方式
    46.全排列
    47.全排列Ⅱ                                  判断条件也有顺序， 树层去重效率高
棋盘问题：
    51.N皇后                  棋盘的宽度就是for循环的长度，递归的深度就是棋盘的高度，这样就可以套                                           进回溯法的模板里了。做到这里我知道了二维切片添加切片的全部奥秘。核心点，之前理解的有误，如果一维切片对后续无影响，直接append就行，如果还要回溯，可能要先解码了
    37.解数独
其他：
    491.递增子序列
    332.重新安排行程